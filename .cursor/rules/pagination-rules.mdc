# Pagination Implementation Rules

## Backend Implementation

### Repository Layer
- **Interface**: Sempre criar método `FindBy{Entity}Paginated(query {Entity}Query) ([]*models.{Entity}, int64, error)`
- **Query Struct**: Use estrutura com `CreatorID`, `SearchTerm`, `Pagination` e filtros específicos
- **Return**: Retorne array de entidades, total de registros e erro

### Service Layer  
- **Interface**: Criar método `Get{Entity}ByCreatorPaginated(creatorID uint, query repository.{Entity}Query) ([]*models.{Entity}, int64, error)`
- **Logic**: Aplicar regras de negócio antes de chamar repository
- **URL Generation**: Gerar URLs de download/acesso se necessário

### Handler Layer
- **Parameters**: Parse `page` e `per_page` da URL query
- **Default**: Use 20 como padrão de itens por página
- **Pagination Object**: Criar com `models.NewPagination(page, perPage)`
- **Set Total**: Sempre chamar `pagination.SetTotal(total)` após query

## Frontend Implementation

### Template Data
- **Pass Pagination**: Sempre incluir `Pagination` no map de dados
- **URL Params**: Manter parâmetros na navegação

### HTML Structure
```html
<!-- Informações de Paginação -->
<div class="d-flex justify-content-between align-items-center mt-3">
    <div class="text-muted small">
        Página {{.Data.Pagination.Page}} de {{.Data.Pagination.TotalPages}} 
        ({{.Data.Pagination.Limit}} por página)
    </div>
    <nav aria-label="Paginação">
        <ul class="pagination pagination-sm mb-0">
            {{if .Data.Pagination.HasPrev}}
            <li class="page-item">
                <a class="page-link" href="?page={{.Data.Pagination.PrevPage}}&per_page={{.Data.Pagination.Limit}}">
                    <i class="mdi mdi-chevron-left"></i>
                </a>
            </li>
            {{end}}
            
            {{range .Data.Pagination.Pages}}
            {{if eq . -1}}
            <li class="page-item disabled">
                <span class="page-link">...</span>
            </li>
            {{else}}
            <li class="page-item {{if eq . $.Data.Pagination.Page}}active{{end}}">
                <a class="page-link" href="?page={{.}}&per_page={{$.Data.Pagination.Limit}}">{{.}}</a>
            </li>
            {{end}}
            {{end}}
            
            {{if .Data.Pagination.HasNext}}
            <li class="page-item">
                <a class="page-link" href="?page={{.Data.Pagination.NextPage}}&per_page={{.Data.Pagination.Limit}}">
                    <i class="mdi mdi-chevron-right"></i>
                </a>
            </li>
            {{end}}
        </ul>
    </nav>
</div>
```

## Models Implementation

### Pagination Struct
```go
type Pagination struct {
    Page       int
    Limit      int
    Total      int64
    Start      int
    End        int
    PrevPage   int
    NextPage   int
    PageSize   int
    TotalPages int
    HasPrev    bool
    HasNext    bool
    Pages      []int
}
```

### Required Methods
- `NewPagination(page, limit int) *Pagination`
- `SetTotal(total int64)` - Calculates all derived fields
- `generatePageNumbers() []int` - Smart page number generation

### Page Number Logic
- **≤7 pages**: Show all pages
- **>7 pages**: Show strategic pages with separators
- **Separators**: Use `-1` to represent "..." in template

## Query Struct Pattern

### Standard Structure
```go
type {Entity}Query struct {
    CreatorID  uint
    SearchTerm string
    FileType   string  // Entity-specific filters
    Pagination *models.Pagination
}
```

### Usage in Repository
```go
func (r *repository) FindByCreatorPaginated(query {Entity}Query) ([]*models.{Entity}, int64, error) {
    var entities []*models.{Entity}
    var total int64

    // Build base query
    db := r.db.Where("creator_id = ?", query.CreatorID)

    // Apply filters
    if query.SearchTerm != "" {
        searchTerm := "%" + query.SearchTerm + "%"
        db = db.Where("name ILIKE ? OR description ILIKE ?", searchTerm, searchTerm)
    }

    // Count total
    if err := db.Model(&models.{Entity}{}).Count(&total).Error; err != nil {
        return nil, 0, err
    }

    // Apply pagination
    if query.Pagination != nil {
        offset := (query.Pagination.Page - 1) * query.Pagination.Limit
        db = db.Offset(offset).Limit(query.Pagination.Limit)
    }

    // Execute query
    err := db.Order("created_at DESC").Find(&entities).Error
    return entities, total, err
}
```

## Testing Pagination

### Mock Updates
- **Repository Mock**: Include `FindByCreatorPaginated` method
- **Service Mock**: Include `GetByCreatorPaginated` method
- **Test Data**: Create pagination objects for tests

### Test Cases
- Test with different page sizes
- Test edge cases (page 0, negative pages)
- Test total calculation
- Test page number generation

## Performance Considerations

### Database
- **Indexes**: Create indexes on `creator_id` and search fields
- **Count Optimization**: Consider separate count queries for performance
- **Limit Results**: Always apply LIMIT to prevent large result sets

### Frontend
- **Loading States**: Show loading during pagination navigation
- **URL State**: Maintain current page in URL for bookmarking
- **Cache**: Consider caching total counts for frequent queries

## URL Patterns

### Standard Format
- `?page=1&per_page=20` - Basic pagination
- `?page=2&per_page=50&search=term` - With search
- `?page=1&per_page=20&type=pdf` - With filters

### Parameter Handling
- **page**: Default to 1 if missing or invalid
- **per_page**: Default to 20, max 100
- **Preserve**: Maintain other query parameters in pagination links
