---
alwaysApply: true
---
# Service Construction Rule

## Localização
- Todos os services devem ser definidos no diretório `internal/service/`.

## Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_service.go` (ex: `client_service.go`).
- O nome da interface principal do service deve ser `<Feature>Service` (ex: `ClientService`).
- O nome da struct de implementação deve ser `<feature>ServiceImpl` (ex: `clientServiceImpl`).

## Estrutura
- O service deve ser implementado como uma interface, definindo os métodos públicos que representam as operações de negócio.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para repositórios e outros serviços necessários.
- O construtor do service deve ser uma função `New<Feature>Service`, recebendo explicitamente as dependências e retornando a interface do service.
- Métodos do service devem ser funções públicas (iniciando com maiúscula).

## Responsabilidade
- O service deve ser responsável apenas por:
  - Conter a lógica de negócio da aplicação.
  - Orquestrar chamadas a repositórios e outros serviços.
  - Garantir regras de negócio e validações complexas.
  - Preparar dados para apresentação no DashUI.
- Não deve conter lógica de acesso a dados diretamente (deve delegar aos repositórios).
- Não deve conter lógica de apresentação ou manipulação de HTTP (deve ser feito nos handlers).

## DashUI Data Preparation
- **Model Methods**: Implementar métodos nos models para formatação de dados (ex: `GetInitials()`, `GetFormattedDate()`)
- **Data Transformation**: Transformar dados do banco para formato adequado ao template
- **Pagination Support**: Retornar dados paginados para listagens
- **Search/Filter Logic**: Implementar lógica de busca e filtros
- **Status Management**: Gerenciar estados e status para badges e indicadores visuais

## Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `CreateClient`, `UpdateClient`).
- Validar e tratar erros de forma consistente, retornando erros claros para os handlers.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada service, cobrindo casos de sucesso e falha.

## Exemplo de estrutura mínima

```go
// internal/service/client_service.go

type ClientService interface {
    CreateClient(input CreateClientInput) (Client, error)
    UpdateClient(id int, input UpdateClientInput) (Client, error)
}

type clientServiceImpl struct {
    clientRepo repository.ClientRepository
}

func NewClientService(clientRepo repository.ClientRepository) ClientService {
    return &clientServiceImpl{clientRepo: clientRepo}
}

func (s *clientServiceImpl) CreateClient(input CreateClientInput) (Client, error) {
    // Lógica de negócio, chamada ao repositório, validação
}
```
