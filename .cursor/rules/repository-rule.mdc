---
alwaysApply: true
---

# Repository Construction Rule

## Localização
- Todos os repositories devem ser definidos no diretório `internal/repository/`.

## Nomeação
- O nome do arquivo deve seguir o padrão: `<feature>_repository.go` (ex: `client_repository.go`).
- O nome da interface principal do repository deve ser `<Feature>Repository` (ex: `ClientRepository`).
- O nome da struct de implementação deve ser `<feature>RepositoryImpl` (ex: `clientRepositoryImpl`).

## Estrutura
- O repository deve ser implementado como uma interface, definindo os métodos públicos para acesso e manipulação de dados.
- A implementação concreta deve ser uma struct, utilizando injeção de dependências para o acesso ao banco de dados (ex: *gorm.DB).
- O construtor do repository deve ser uma função `New<Feature>Repository`, recebendo explicitamente as dependências e retornando a interface do repository.
- Métodos do repository devem ser funções públicas (iniciando com maiúscula).

## Responsabilidade
- O repository deve ser responsável apenas por:
  - Realizar operações de acesso a dados (CRUD) e consultas específicas.
  - Mapear entidades do domínio para o banco de dados e vice-versa.
  - Implementar consultas otimizadas para listagens e dashboards.
- Não deve conter lógica de negócio (deve ser feita nos services).
- Não deve conter lógica de apresentação ou manipulação de HTTP.

## DashUI Query Optimization
- **Pagination Support**: Implementar queries com `LIMIT` e `OFFSET` para paginação eficiente
- **Search Queries**: Criar consultas otimizadas para busca em múltiplos campos
- **Filter Support**: Implementar filtros dinâmicos para diferentes critérios
- **Count Queries**: Separar queries de contagem para paginação precisa
- **Eager Loading**: Usar `Preload` para carregar relacionamentos necessários
- **Index Optimization**: Garantir que queries frequentes tenham índices adequados

## Boas práticas
- Utilizar nomes claros e descritivos para métodos, refletindo a ação executada (ex: `Create`, `FindByID`, `Update`, `Delete`).
- Validar e tratar erros de forma consistente, retornando erros claros para os services.
- Utilizar interfaces para facilitar testes e mock.
- Sempre incluir testes para cada repository, cobrindo casos de sucesso e falha.

## Exemplo de estrutura mínima

```go
// internal/repository/client_repository.go

type ClientRepository interface {
    Create(client *models.Client) error
    FindByID(id int) (*models.Client, error)
    Update(client *models.Client) error
    Delete(id int) error
}

type clientRepositoryImpl struct {
    db *gorm.DB
}

func NewClientRepository(db *gorm.DB) ClientRepository {
    return &clientRepositoryImpl{db: db}
}

func (r *clientRepositoryImpl) Create(client *models.Client) error {
    // Operação de inserção no banco de dados
}
```
